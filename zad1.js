function arrFunc(arr){
let j=0; //четные элементы
let k=0;//нечетные элементы
let y=0;// нулевые элементы
for(let i=0; i<=arr.length; i++) {
	
if (typeof arr[i]==='number'&& arr[i] %2===0&&arr[i]!=0&&arr[i]!=null){
	j++;}
	else if (typeof arr[i]==='number' && arr[i]%2===1){
	k++;}
	else if(arr[i]===0||arr[i]===null||arr[i]===''){
		y++;}	
}
console.log('четных элементов в массиве -'+j+' '+
' нечетных элементов в массиве -'+k+' '+
' нулевых элементов в массиве - '+ y);
}
let arr = [20,32,1,0,21,32,533,22,11,'text',null];
arrFunc(arr);

// Задание выполнено неверно. Есть несколько ошибок:
// 1. Функция объявлена без аргумента, и внутри функции вы используете массив, заданный извне. В таком виде функция не имеет смысла, потому что вы не можете использовать эту функцию для проверки других массивов, не меняя кода функции, т.е. не можете переиспользовать её. Вам нужно задать для функции аргумент и использовать для каждой проверки массив, переданный в функцию. Выше исправила эту ошибку
// (эти ошибки остались с аналогичного задания предыдущего модуля, на всякий случай перечислю их ещё раз)
// 2. Когда вы хотите отобрать только числа, проверки на typeof недостаточно, нужно добавлять и проверку на NaN, т.к. тип значения NaN тоже равен number.
// 3. Значения null не являются нулями, это специальное значение, которое обозначает по сути отутствие значения. Поэтому их не нужно учитывать при подсчете нулей. То же самое касается пустой строки

// Также пару рекомендаций:
// 1. Если видите, что в условиях повторяются одни и те же проверки, подумайте, как можно оптимизировать код и сократить количество проверок. Можно делать вложенные условия например
// 2. Если вам нужно вывести строку, в которую включаются какие-то переменные, лучше использовать шаблонные строки (в обратных кавычках - ``). В них вы можете вставлять непосредственно переменные с помощью такой конструкции - ${value}. Это здорово улучшает читабельность кода.
// 3. Давайте переменным осмысленные имена, потому что даже в коде такого небольшого объема сложно ориентироваться, когда по названию непонятно, что содержит в себе каждая переменная. В более сложных проектах это гарантированно приведет к путанице.

// Попробуйте взять исправленный вариант задания из предыдущего модуля и на его основе провести работу над ошибками и исправить это решение